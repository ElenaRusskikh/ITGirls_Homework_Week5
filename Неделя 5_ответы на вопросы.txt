1. Почему в большинстве ситуаций стоит использовать flexbox-позиционирование?

flexbox-позиционирование является самым простым и удобным вариантом. С помощью этой технологии можно очень просто и гибко расставить элементы в контейнере, распределить доступное пространство между ними, и выровнять их тем или иным способом даже если они не имеют конкретных размеров. Flexbox позволяет создать адаптивный дизайн намного проще, чем с использованием других видов позиционирования.

2. Самостоятельно изучите способ позиционирования через `display: table`  и ответьте на вопрос, для каких ситуаций оно лучше всего подходит? 

Такой способ позиционирования лучше всего подходит, когда нужно создать действительную таблицу, ввести табличные данные.

3. Какими способами можно сделать горизонтальное выравнивание по центру? Минимум 3 варианта, можно больше

1) селектор {justify-content: center};
2) селектор {text-align: center};
3) селектор {margin: 0 auto};

4. Какие есть оси во флекс-верстке и как задается их направление?

Во флекс-верстке есть главная ось (по умолчанию она направлена слева направо) и поперечная (по умолчанию направлена сверху вниз), она всегда перпендикулярно главной. Главная ось задаёт основное направление flex-элементов во flex-контейнере, а поперечная ось определяет их направление при переносе на новую линию.
Направление осей задается:
- главной оси - с помощью CSS-свойства flex-direction и значений row (направление слева направо по умолчанию), row-reverse (направление справа налево), column (направление сверху вниз), column-reverse (направление снизу вверх).
- поперечной оси - с помощью CSS-свойства flex-wrap и значений nowrap (размещение только по одной линии по умолчанию), wrap (разрешить перенос flex-элементов на новые линии), wrap-reverse (перенос flex-элементов осуществляется в обратной порядке).

5. Разберитесь, как работает свойство `margin: auto` во флекс-верстке, приведите пример использования

Свойство margin: auto используется для центрирования элемента по вертикали и горизонтали.
Если центрируемых flex-элементов в контейнере будет несколько, то отступы между ними будут равномерными.
Отличие свойства margin у flexbox:
-внешние отступы соседних flex-элементов никогда не объединяются;
-внешние отступы не выпадают, ни из flex-контейнера, ни из flex-элементов;
-если внутри flex-контейнера есть свободное место, то оно перераспределяется так:
1. Находятся элементы, у которых есть внешние отступы со значением auto;
2. Все свободное место в соответствующих направлениях отдается таким отступам;
3. Если элементов с автоматическими отступами на одном направлении несколько, то место между ними распределяется поровну.
4. Только после этого происходит выравнивание. margin: auto влияет на положение flex-элементов на обеих осях. “Выравнивание” происходит только если свободное место осталось. 
margin: auto ничего не знает про направления главной и поперечной оси. Это свойство “мыслит” старыми понятиями: верх, право, низ, лево. Когда главная ось направлена слева направо, горизонтальные отступы перемещают flex-элементы вдоль главной оси. Но если направить главную ось сверху вниз, то те же отступы начнут работать вдоль поперечной оси.
Пример использования в файле question5 (пример c margin-left:auto).

6. В чем преимущества `box-sizing`?

Cвойство box-sizing позволяет точно знать, как блочная модель работает и как вычисляются размеры элемента. Это свойство имеет два основных значения: content-box (значение по умолчанию. Размер элемента начинается со свойств width и height, далее к ним добавляются значения свойств padding, border или margin) и border-box (изменяет блочную модель так, чтобы любые значения свойств border или padding включались внутри width и height элемента. Н-р, если для элемента указаны width 400 пикселей, padding 20 пикселей и border 10 пикселей вокруг всех сторон, фактическая ширина останется 400 пикселей).

7. Чем отличается `flex-grow` от `flex-shrink`?

Свойство flex-grow определяет, может ли ширина элемента увеличиться за счет имеющегося свободного пространства линии.
Свойство flex-shrink определяет, может ли ширина элемента уменьшиться. Ширина flex-элемента будет уменьшаться, только если ширины линии будет не достаточно для отображения всех расположенных в ней flex-элементов.

8. Как можно добиться следующего позиционирования элементов:
    
    С помощью justify-content: space-between;
    
9. Какой в итоге будет размер у элемента (можно округлить)? 
    
    Ширина=148,523px; высота=17,807px.
    
10. Самостоятельно разберитесь, зачем нужно свойство `order`?

Свойство order задает порядок следования отдельно взятого flex-блока внутри flex-контейнера. Применяется к конктретному flex-блоку. Принимает значение положительно или отрицательного целого числа. Чем меньше число, тем раньше будет стоять элемент, независимо от расположения в html коде относительно других элементов.

11. Каким кодом можно сделать такую таблицу?
    
    Таблица выполнена в файле table.html
    
12. Изучите материалы и найдите, для каких ситуаций подходит `position: fixed`? 

Элемент с position: fixed при прокручивании страницы остаётся на своём месте и не прокручивается вместе со страницей.
Используется, например, для ссылки "Наверх", чтобы с любого места на странице вернуться в начало; для вывода диалоговых окон и окон сообщений; для создания меню; для заголовков.

13. Каким способом лучше всего верстать большие блоки текста?

С помощью блочной модели.

14. Как рассчитывается размер flex-контейнера?

Размер flex-контейнера=размеры содержимого (flex-элементов)+размеры внутреннего отступа+границы

